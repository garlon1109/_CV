- # 图像基础处理算法

    在浏览器添加 [MathJax Plugin for Github](https://chrome.google.com/webstore/detail/mathjax-plugin-for-github/ioemnmodlmafdkllaclgeombjnmnbima) 插件可以使得数学公式正常渲染。

    ## 源代码

    - [Implementation of median filtering](https://github.com/SummerLife/EmbeddedSystem/blob/master/CV/week2/medianblur.py)

    ## 基本概念

    ### 图像就是函数

    我们能把一幅灰度图像看作是一个二维函数，定义成 f(x, y) 或者 I(x, y)。任何一对空间坐标 (x, y) 处 f 的值看作该坐标点处的强度 (intensity) 或灰度。对于彩色图像，同样可以看作是一个向量函数 `f(x, y) = [r(x, y), g(x, y), b(x, y)]`。

    ### 灰度图

    灰度可以认为是亮度，简单说就是色彩的深浅程度。

    灰度就是没有色彩，RGB 色彩分量全部相等（可以使用画图工具来做测试，如果 RGB 三个通道的值都相等，那么最终的颜色就是从纯黑到白之间不同等级的灰色）。如果一个二值灰度图像，它的像素值只能为 0 或 1，我们说它的灰度级为2.用个例子来说吧：一个256级灰度图你，　　　

    - RGB（100，100，100）就代表灰度为100，RGB（50，50，50）就代表灰度为50。

    灰度是指黑白图像中的颜色深度，范围一般0-255，白色为255，黑色为0，故黑白图片也称为灰度图像。 　　若是彩色图像的灰度其实是在转化为黑白图像后的像素值（是一种广义的提法），转化的方法看应用领域而定，一般按加权的方法转换，R,G,B的一般比例为3： 6：1。 任何颜色都有红、绿、蓝三原色组成，假如原来某点的颜色为RGB（R,G,B），那么，我们可以通过下面几种方法，将其转换为灰度：

    ```
    　　1.浮点算法：Gray = R*0.3 + G*0.59 + B*0.11
    　　2.整数方法：Gray = (R*30+G*59+B*11)/100
    　　3.移位方法：Gray =（R*28+G*151+B*77）>> 8
    　　4.平均值法：Gray = (R+G+B)/3
    　　5.仅取绿色：Gray = G
    ```

    通过以上任何一种方法求得 Gray 后，将原来的 RGB（r,g,b) 中的 r,g,b 统一用 Gray 替换，形成新的颜色 RGB(Gray,Gray,Gray)，用它替换原来的 RGB（r,g,b) 就是灰度图了。

    ### 灰度直方图

    灰度直方图是关于灰度级分布的函数，是对图像中灰度级分布的统计。灰度直方图是将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率。灰度直方图是灰度级的函数，它表示图像中具有某种灰度级的像素的个数，反映了图像中某种灰度出现的频率。

    如果将图像总像素亮度（灰度级别）看成是一个随机变量，则其分布情况就反映了图像的统计特性，这可用 probability density function （PDF）来刻画和描述，表现为灰度直方图。

    ### 图像梯度

    当用均值滤波器降低图像噪声的时候，会带来图像模糊的副作用。我们当然希望看到的是清晰图像。那么，清晰图像和模糊图像之间的差别在哪里呢？从逻辑上考虑，图像模糊是因为图像中物体的轮廓不明显，轮廓边缘灰度变化不强烈，层次感不强造成的，那么反过来考虑，轮廓边缘灰度变化明显些，层次感强些是不是图像就更清晰些呢。

    那么，这种灰度变化明显不明显怎样去定义呢。我们学过微积分，知道微分就是求函数的变化率，即导数（梯度），那么对于图像来说，也可以用微分来表示图像灰度的变化率。

    ## 卷积

    ## 图像滤波

    图像滤波既可以在实域进行，也可以在频域进行。图像滤波可以更改或者增强图像。通过滤波，可以强调一些特征或者去除图像中一些不需要的部分。滤波是一个邻域操作算子，利用给定像素周围的像素的值确定次像素的最终输出值。

    $$ O(i,j)=∑_{m,n}I(i+m,j+n)∗K(m,n) $$

    其中 K 为滤波器，在很多文献中也成为核（kernel）。常见的应用包括去噪、图像增强、检测边缘、检测角点、模板匹配等。

    ### 图像锐化与边缘检测应用

    图像锐化，求边缘等是常见的图像滤波应用。这类滤波器常常使用一节或者二阶差分（或微分，对于数字图像而言，其为离散信号，长用差分代替导数）核算子对图像进行滤波。一节差分常用于求取图像边缘。二阶差分常用于图像增强。常用的这类算子包括：

    #### Sobel

    Sobel operator：Sobel 算子通过计算水平和垂直方向上的一节差分来进行计算。在 OpenCV 函数中，可通过使用 [Sobel](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=sobel#sobel) 函数进行计算。

    #### Laplacian

    Laplacian operator：Laplacian 算子通过计算二阶差分（微分）来进行计算。在 OpenCV 函数中，可通过使用 [Laplacian](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=laplacian#laplacian) 函数进行计算。

    ### 图像平滑应用

    用于平滑图像的常见滤波算子包括：

    #### 均值滤波

    用其像素点周围像素的平均值代替原像素值，在滤除噪声的同时也会滤掉图像的边缘信息。在 OpenCV 中，可以使用 `boxFilter` 和 blur 函数进行均值滤波，均值滤波的核为：

    [![\frac{1}{ksize.width{\cdot}ksize.height}\begin{bmatrix} {1}&{1}&{\cdots}&{1}\ {1}&{1}&{\cdots}&{1}\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\ {1}&{1}&{\cdots}&{1}\ \end{bmatrix}](https://camo.githubusercontent.com/efcb3e74221111209f9d66500acc77eb9e8138de/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f25354366726163253742312537442537426b73697a652e776964746825374225354363646f742537446b73697a652e686569676874253744253543626567696e253742626d6174726978253744253230253742312537442532362537423125374425323625374225354363646f747325374425323625374231253744253543253543253230253742312537442532362537423125374425323625374225354363646f74732537442532362537423125374425354325354325323025374225354376646f747325374425323625374225354376646f747325374425323625374225354364646f747325374425323625374225354376646f7473253744253543253543253230253742312537442532362537423125374425323625374225354363646f747325374425323625374231253744253543253543253230253543656e64253742626d6174726978253744)](https://camo.githubusercontent.com/efcb3e74221111209f9d66500acc77eb9e8138de/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f25354366726163253742312537442537426b73697a652e776964746825374225354363646f742537446b73697a652e686569676874253744253543626567696e253742626d6174726978253744253230253742312537442532362537423125374425323625374225354363646f747325374425323625374231253744253543253543253230253742312537442532362537423125374425323625374225354363646f74732537442532362537423125374425354325354325323025374225354376646f747325374425323625374225354376646f747325374425323625374225354364646f747325374425323625374225354376646f7473253744253543253543253230253742312537442532362537423125374425323625374225354363646f747325374425323625374231253744253543253543253230253543656e64253742626d6174726978253744)

    #### 中值滤波（MedianFilter）

    中值滤波用测试像素周围邻域像素集中的中值代替原像素。中值滤波去除椒盐噪声和斑块噪声时，效果非常明显。在 OpenCV 中可以用函数 `medianBlur` 进行操作。

    无论是平均平滑还是高斯平滑，在处理图像噪声时，都或多或少会对图片产生一定的模糊，损失部分信息。较为理想的情况，是可以选择性地进行滤波，只在噪声区域进行平滑，而在无噪声区域不进行平滑，将模糊的影响降到最低，这就是自适应性滤波的思想。通常噪声的存在，可能会使得附近邻域内，极值的上下差距较大，或者是方差较大，我们可以设置一定的阈值来判断该点是否需要进行平滑。不过这个不是该章节的内容，这一章是要学习中值滤波，中值滤波本质上是一个**统计排序滤波器**，是以该点为中心的的邻域内的所有像素的统计排序中值作为该点的响应；而平滑就是加权平均数作为响应，概念上有一定差别。

    不同的滤波器在处理不同类型的噪声是效果不同，对于线性平滑滤波，在处理像素邻域内的噪声点时，噪声或多或少都会影响该点的像素值计算(以高斯平滑为例，距离近则影响大，距离远则影响小，与距离的平方呈反比)；但是中值滤波通常可以将噪声点直接忽略掉。同时，中值滤波在降噪的同时引起的模糊效应较低。中值滤波的一种典型应用，就是用来消除椒盐(salt & pepper)噪声。

    #### 高斯滤波

    高斯滤波为最常用的滤波器，具有可分离性质，可以把二维高斯运算转换为一维高斯运算，其本质上为一个低通滤波器。在OpenCV中可通过函数 [GaussianBlur](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=gaussianblur#gaussianblur) 进行操作。

    模糊的算法有很多种，其中一种叫做高斯模糊（Gaussian Blur）。它将正态分布（又名高斯分布）用于图像处理。高斯模糊本质是一种数据平滑技术（data smoothing），适用于多个场合，图像处理提供了一个直观的应用实例可参考 [《高斯模糊（高斯滤波）的原理与算法》](https://blog.csdn.net/nima1994/article/details/79776802)。

    - 均值滤波是简单的取平均值，模板系数都是 1。而图像上的像素实际上是坐标离散但是值却连续的，因为与靠近点的关系越密切，越远离的点关系越疏远。因此，加权平均更合理，举例越近的点权重越大，距离越远的点权重越小
    - 既然是依据距离来加权平均，那么很容易想到高斯函数 $f(x) = \frac{1}{\sigma\sqrt{2\pi }}{e}^{\frac{-(x-\mu )^{2}}{2\sigma^2}}$，从高斯函数来看，离原点距离越近，得到的权重越高，越远离原点，得到的权重越小
    - 一维的高斯函数，当中心点为原点时，x 的均值 μ = 0， 此时 $f(x) = \frac{1}{\sigma\sqrt{2\pi }}{e}^{\frac{-x^{2}}{2\sigma^2}}$
    - 由于图像是二维矩阵，则采用二维高斯函数 $f(x,y) = \frac{1}{{2\pi }\sigma^2}{e}^{\frac{-(x^2+y^2 )}{2\sigma^2}}$，有了这个函数就可以计算滤波模板中各个点的权重了

    ##### 生成高斯核

    通过 cv2 中的 `getGaussianKernel` 函数可以根据指定参数规模和方差生成高斯卷积核：

    ```
    k = cv2.getGaussianKernel(3,1.5)
    ```

    通过该函数生成的一维卷积核 k 已经进行过归一化处理。

    归一化化定义：归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在你需要的一定范围内。 首先归一化是为了后面数据处理的方便，其次是保证程序运行时收敛加快。归一化的具体作用是归纳统一样本的统计分布性。 归一化在0-1之间是统计的概率分布，归一化在某个区间上是统计的坐标分布。归一化有同一、统一和合一的意思。

    - 规模为`3*3`，方差为 1.5 的一维卷积核 k 为：

    ```
    [[0.30780133]
     [0.38439734]
     [0.30780133]]
    ```

    - 通过 k*(k.T) 运算可以获得二维卷积核

    ```
    [[0.09474166 0.11831801 0.09474166]
     [0.11831801 0.14776132 0.11831801]
     [0.09474166 0.11831801 0.09474166]]
    ```

    ##### 高斯滤波加速

    对图像进行高斯滤波而言，假设滤波器半径为 r，我们常用的高斯模板则对于图像每个像素的算法复杂度是 O(r^2)。高斯滤波器的 kernel 是可分离的(separable)，也就是说，可以将 2D 的高斯 kernel 分解为两个 1D 的 kernel，先沿 x 方向对图像进行 1D 高斯 kernel 的卷积，然后沿 y 方向对图像进行 1D 的高斯 kernel 卷积，最后的结果和使用一个 2D 高斯 kernel 对图像卷积效果是一样的。这样一来，针对每个像素，滤波器的算法复杂度降为 O(r)。

    ### 双边滤波

    双边滤波在平滑图像时能够很好的保留边缘特性，但是其运算速度比较慢。在 OpenCV 中，可以使用函数 [bilateralFilter](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=bilateralfilter#bilateralfilter) 进行操作。

    ### 自定义滤波器

    除了上面列举的较为经典的滤波器（或者说是核算子）外，在 OpenCV 中也可以自己定义自己的滤波器，然后使用 [filter2D](http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=filter2d#filter2d) 函数进行运算。